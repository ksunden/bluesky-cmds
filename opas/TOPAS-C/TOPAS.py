### import ####################################################################


import os
import time
import collections

from PyQt4 import QtGui, QtCore

import ctypes
from ctypes import *

import WrightTools as wt
import WrightTools.units as wt_units

import project.classes as pc
import project.widgets as pw
import project.project_globals as g
from project.ini_handler import Ini
main_dir = g.main_dir.read()
ini = Ini(os.path.join(main_dir, 'opas',
                                 'TOPAS-C',
                                 'TOPAS.ini'))


### api object ################################################################

#IMPORTANT: THE WINDLL CALL MUST HAPPEN WITHIN THE TOPAS DRIVER FOLDER (os.chdir())

driver_folder = os.path.join(main_dir, 'opas', 'TOPAS-C', 'configuration', 'drivers')
os.chdir(driver_folder)
dll_path = os.path.join(driver_folder, 'TopasAPI.dll')
dll = ctypes.WinDLL(dll_path)
os.chdir(main_dir)

global opas_loaded
opas_loaded = []

class TOPAS():
    def __init__(self, ini_filepath):
        global opas_loaded
        if len(opas_loaded) >= 3:
            print 'Cannot load more than 3 TOPAS OPAs: DLL restriction'
            return
        self.index = len(opas_loaded)
        self._open_device(ini_filepath)
        opas_loaded.append(self._get_device_serial_number()[1])
    def close(self):
        '''
        int index \n
        returns [error code]
        '''
        index = c_ushort(self.index)
        error = dll.Topas_CloseDevice(index)
        global opas_loaded
        opas_loaded.pop(index.value) #remove serial number from opas_loaded
        return [error]
    def _convert_position_to_steps(self, motor_index, position):
        '''
        int motor_index, float position (absolute geometry) \n
        returns [error code, int position (microsteps)]
        '''
        steps = c_uint()
        error = dll.Topas_ConvertPositionToSteps(c_ushort(self.index), c_ushort(motor_index), c_double(position), pointer(steps))
        return [error, int(steps.value)]
    def _convert_position_to_units(self, motor_index, position):
        '''
        int motor index, int position (microsteps) \n
        returns [error code, float position (absolute geometery)] \n
        '''
        geometric_position = c_double()
        error = dll.Topas_ConvertPositionToUnits(c_ushort(self.index), c_ushort(motor_index), c_ushort(position), pointer(geometric_position))
        return [error, geometric_position.value]
    def _get_count_of_devices(self):
        '''
        returns [error code, int count_of_devices]
        '''
        #no error code is actually generated by dll, I fake it for the sake of consistency
        count_of_devices = dll.Topas_GetCountOfDevices()
        return [0, count_of_devices]
    def get_count_of_motors(self):
        '''
        returns [error code, int count_of_motors]
        '''
        number_of_device_motors =  c_ushort()
        error = dll.Topas_GetCountOfMotors(c_ushort(self.index), pointer(number_of_device_motors))
        return [error, number_of_device_motors.value]
    def _get_device_serial_number(self):
        '''
        returns [error code, int device_serial_number]
        '''
        serial_number = c_ulong()
        size = 8
        error = dll.Topas_GetDeviceSerialNumber(c_ushort(self.index), pointer(serial_number), c_ushort(size))
        return [error, int(serial_number.value)]
    def get_interaction(self, stage):
        '''
        int index, int stage \n
        returns [error code, int interaction]'
        '''
        interaction = c_ushort()
        error = dll.Topas_GetInteraction(c_ushort(self.index), c_ushort(stage), pointer(interaction))
        return [error, interaction.value]
    def _get_motor_affix(self, motor_index):
        '''
        int index, int motor_index \n
        returns [error code, float motor_affix]
        '''
        motor_affix = c_double()
        error = dll.Topas_GetMotorAffix(c_ushort(self.index), c_ushort(motor_index), pointer(motor_affix))
        return [error, motor_affix.value]
    def _get_motor_offset(self, stage, interaction_index, motor_index):
        '''
        int index, int stage, int interaction_index, int motor_index \n
        returns [error code, float offset]
        '''
        offset = c_double()
        error = dll.Topas_GetMotorOffset(c_ushort(self.index), c_ushort(stage), c_ushort(interaction_index), c_ushort(motor_index), pointer(offset))
        return [error, offset.value]
    def get_motor_position(self, motor_index):
        '''
        int index, int motor_index \n
        returns [error code, position]
        '''
        position = c_uint()
        error = dll.Topas_GetMotorPosition(c_ushort(self.index), c_ushort(motor_index), pointer(position))
        return [error, int(position.value)]
    def get_motor_positions_range(self, motor_index):
        '''
        int index, int motor_index \n
        returns [error code, min_position, max_position]
        '''
        min_position = c_uint()
        max_position = c_uint()
        error = dll.Topas_GetMotorPositionsRange(c_ushort(self.index), c_ushort(motor_index), pointer(min_position), pointer(max_position))
        return [error, int(min_position.value), int(max_position.value)]
    def _get_reference_switch_status(self, motor_index):
        '''
        int index, int motor_index \n
        reference switches will return as true when limit switch is depressed \n
        returns [error code, bool left_reference_switch, bool right_reference_switch]
        '''
        left_reference_switch = c_ushort()
        right_reference_switch = c_ushort()
        error = dll.Topas_GetReferenceSwitchStatus(c_ushort(self.index), c_ushort(motor_index), pointer(left_reference_switch), pointer(right_reference_switch))
        return [error, bool(left_reference_switch), bool(right_reference_switch)]
    def _get_speed_parameters(self, motor_index):
        '''
        int motor_index \n
        returns [error code, int min_speed, int max_speed, int acceleration]
        '''
        min_speed = c_uint()
        max_speed = c_uint()
        acceleration = c_uint()
        error = dll.TopasUSB_GetSpeedParams(c_ushort(self.index), c_ushort(motor_index), pointer(min_speed), pointer(max_speed), pointer(acceleration))
        return [error, int(min_speed.value), int(max_speed.value), int(acceleration.value)]
    def get_wavelength(self, stage):
        '''
        int index, int stage \n
        returns [error code, float wavelength (nm)]
        '''
        wavelength = c_float()
        error = dll.Topas_GetWl(c_ushort(self.index), c_ushort(stage), pointer(wavelength))
        return [error, float(wavelength.value)]
    def is_motor_still(self, motor_index):
        '''
        int index, int motor_index \n
        returns [error code, bool result]
        '''
        result = c_void_p()
        error = dll.Topas_IsMotorStill(c_ushort(self.index), c_ushort(motor_index), pointer(result))
        return [error, bool(result)]
    def _is_wavelength_setting_finished(self):
        '''
        int index \n
        returns [error code, bool result]
        '''
        result = c_void_p()
        error = dll.Topas_IsWavelengthSettingFinished(c_ushort(self.index), pointer(result))
        return [error, bool(result)]
    def _move_motor(self, motor_index, new_position):
        '''
        get_interaction
        int index, int motor_index, int_new_position \n
        new_position in microsteps \n
        returns [error code]
        '''
        return [dll.Topas_MoveMotor(c_ushort(self.index), c_ushort(motor_index), c_uint(new_position))]
    def _move_motor_to_position_units(self, motor_index, position):
        '''
        int motor_index, float position (absolute geometry) \n
        returns [error code]
        '''
        return [dll.Topas_MoveMotorToPositionInUnits(c_ushort(self.index), c_ushort(motor_index), c_double(position))]
    def _open_device(self, ini_filepath):
        '''
        int index, str ini_filepath \n
        index between 0 and 3 \n
        returns [assigned index]
        '''
        return [dll.Topas_OpenDevice(c_ushort(self.index), ini_filepath)]
    def set_shutter(self, shutter_state):
        '''
        int index, bool shutter_state \n
        shutter open when shutter_state = True \n
        returns [error code]
        '''
        return [dll.Topas_OpenShutter(c_ushort(self.index), c_ushort(not shutter_state))]
    def _set_motor_affix(self, motor_index, affix):
        '''
        int motor index, float affix (absolute geometry) \n
        returns [error code]
        '''
        return [dll.Topas_SetMotorAffix(c_ushort(self.index), c_ushort(motor_index), c_double(affix))]
    def _set_motor_offset(self, stage, interaction, motor_index):
        '''
        int stage, int interaction, int motor_index, float offset (relative geometry) \n
        returns [error code]
        '''
        return [dll.Topas_SetMotorOffset(c_ushort(self.index), c_ushort(stage), c_ushort(interaction), c_ushort(motor), c_double(offset))]
    def set_motor_position(self, motor_index, counter_position):
        '''
        int motor_index, int counter_position (microsteps) \n
        returns [error code]
        '''
        return [dll.Topas_SetMotorPosition(c_ushort(self.index), c_ushort(motor_index), c_uint(counter_position))]
    def _set_motor_positions_range(self, motor_index, min_position, max_position):
        '''
        int motor_index, int min_position (microsteps), int max_position (microsteps) \n
        returns [error code]
        '''
        return [dll.Topas_SetMotorPositionsRange(c_ushort(self.index), c_ushort(motor_index), c_uint(min_position), c_uint(max_position))]
    def _set_speed_parameters(self, motor_index, min_speed, max_speed, acceleration):
        '''
        int motor_index, int min_speed, int max_speed \n
        returns [error code]
        '''
        return [dll.TopasUSB_SetSpeedParams(c_ushort(self.index), c_ushort(motor_index), c_uint(min_speed), c_uint(max_speed), c_uint(acceleration))]
    def _set_wavelength(self, wavelength):
        '''
        float wavelength \n
        returns [error code]
        '''
        return [dll.Topas_SetWavelength(c_ushort(self.index), c_double(wavelength))]
    def _set_wavelength_ex(self, wavelength, base_interaction, mixer1_interaction, mixer2_interaction, mixer3_interaction):
        '''
        float wavelength, int base_interaction, int mixer1_interaction, int mixer2_interaction, int mixer3_interaction \n
        returns [error code]
        '''
        return [dll.Topas_SetWavelengthEx(c_ushort(self.index), c_double(wavelength), c_ushort(base_interaction), c_ushort(mixer1_interaction), c_ushort(mixer2_interaction), c_ushort(mixer3_interaction))]
    def _start_motor_motion(self, motor_index, towards):
        '''
        int motor_index, int towards (microsteps) \n
        returns [error code]
        '''
        return [dll.Topas_StartMotorMotion(c_ushort(self.index), c_ushort(motor_index), c_uint(towards))]
    def _start_setting_wavelength(self, wavelength):
        '''
        float wavelength \n
        returns [error code]        
        '''
        return [dll.Topas_StartSettingWavelength(c_ushort(self.index), c_double(wavelength))]
    def _start_setting_wavelength_ex(self, wavelength, base_interaction, mixer1_interaction, mixer2_interaction, mixer3_interaction):
        '''
        float wavelength, int base_interaction, int mixer1_interaction, int mixer2_interaction, int mixer3_interaction \n
        returns [error code]
        '''
        return [dll.Topas_StartSettingWavelengthEx(c_ushort(self.index), c_double(wavelength), c_ushort(base_interaction), c_ushort(mixer1_interaction), c_ushort(mixer2_interaction), c_ushort(mixer3_interaction))]
    def _stop_motor(self, motor_index):
        '''
        int motor_index \n
        returns [error code]
        '''
        return [dll.Topas_StopMotor(c_ushort(self.index), c_ushort(motor_index))]
    def _update_motors_positions(self):
        '''
        returns [error code]
        '''
        return [dll.Topas_UpdateMotorsPositions(c_ushort(self.index))]


### OPA object ################################################################


class OPA:

    def __init__(self):
        self.native_units = 'nm'
        # mutex attributes
        self.limits = pc.NumberLimits(units=self.native_units)
        self.current_position = pc.Number(name='Color', initial_value=1300.,
                                          limits=self.limits,
                                          units=self.native_units, display=True,
                                          set_method='set_position')
        self.offset = pc.Number(initial_value=0, units=self.native_units, display=True)
        self.shutter_position = pc.Bool(name='Shutter',
                                        display=True, set_method='set_shutter')
        # objects to be sent to PyCMDS
        self.exposed = [self.current_position, self.shutter_position]
        self.recorded = collections.OrderedDict()
        self.motor_names = ['crystal 1', 'delay 1', 'crystal 2', 'delay 2', 'mixer 1', 'mixer 2', 'mixer 3']
        # finish
        self.gui = GUI(self)
        self.initialized = pc.Bool()

    def close(self):
        self.api.close()

    def load_curve(self, filepath, polyorder = 4):
        pass

    def get_points(self):
        pass

    def get_position(self):
        pass

    def get_motor_positions(self, inputs=[]):
        for motor_index, motor_mutex in enumerate(self.motor_positions.values()):
            error, position = self.api.get_motor_position(motor_index)
            motor_mutex.write(position)
    
    def get_speed_parameters(self, inputs):
        motor_index = inputs[0]
        error, min_speed, max_speed, acceleration = self.api._get_speed_parameters(motor_index)
        return [error, min_speed, max_speed, acceleration]

    def initialize(self, inputs, address):
        '''
        OPA initialization method. Inputs = [index]
        '''
        self.address = address
        self.index = inputs[0]
        self.serial_number = ini.read('OPA' + str(self.index), 'serial number')
        # load api 
        self.TOPAS_ini_filepath = os.path.join(g.main_dir.read(), 'opas', 'TOPAS-C', 'configuration', str(self.serial_number) + '.ini')
        self.api = TOPAS(self.TOPAS_ini_filepath)
        # motor positions
        self.motor_positions = collections.OrderedDict()
        for motor_index, motor_name in enumerate(self.motor_names):
            error, min_position, max_position = self.api.get_motor_positions_range(motor_index)
            limits = pc.NumberLimits(min_position, max_position)
            number = pc.Number(initial_value=0, limits=limits, display=True)
            self.motor_positions[motor_name] = number
        self.get_motor_positions()
        # tuning curves
        self.curve_path = pc.Filepath()



        # finish
        self.get_position()
        self.initialized.write(True)
        self.address.initialized_signal.emit()       

    def is_busy(self):
        for motor_index in self.api.get_count_of_motors():
            if not self.api.is_motor_still(motor_index):
                return True
        return False

    def is_valid(self, destination):
        return True

    def set_offset(self, offset):
        pass

    def set_position(self, destination):
        pass
        
    def set_position_except(self, inputs):
        '''
        set position, except for motors that follow
        
        does not wait until still...
        '''
        pass
        
    def set_motor(self, inputs):
        '''
        inputs [motor_name (str), destination (mm)]
        '''
        pass

    def set_motors(self, inputs):
        for motor_index, destination in enumerate(inputs):
            self.api.set_motor_position(motor_index, int(destination))
        while self.is_busy:
            time.sleep(0.01)
            self.get_motor_positions()
        self.get_motor_positions()
    
    def set_shutter(self, inputs):
        shutter_state = inputs[0]
        error = self.api.set_shutter(shutter_state)
        self.shutter_position.write(shutter_state)
        return error
         
    def set_speed_parameters(self, inputs):
        motor_index, min_speed, max_speed, accelleration = inputs
        error = self.api._set_speed_parameters(motor_index, min_speed, max_speed, acceleration)
        return error
    
    def wait_until_still(self, inputs=[]):
        pass
    
    
def OPA_offline(OPA):
    
    def initialize(self):
        pass

    
### gui #######################################################################


class GUI(QtCore.QObject):

    def __init__(self, driver):
        QtCore.QObject.__init__(self)
        self.driver = driver

    def create_frame(self, layout):
        layout.setMargin(5)
        self.layout = layout
        self.frame = QtGui.QWidget()
        self.frame.setLayout(self.layout)
        g.module_advanced_widget.add_child(self.frame)
        if self.driver.initialized.read():
            self.initialize()
        else:
            self.driver.initialized.updated.connect(self.initialize)

    def initialize(self):
        # container widget
        display_container_widget = QtGui.QWidget()
        display_container_widget.setLayout(QtGui.QVBoxLayout())
        display_layout = display_container_widget.layout()
        display_layout.setMargin(0)
        self.layout.addWidget(display_container_widget)
        # plot
        self.plot_widget = pw.Plot1D()
        self.plot_widget.plot_object.setMouseEnabled(False, False)
        self.plot_curve = self.plot_widget.add_scatter()
        self.plot_widget.set_labels(ylabel = 'mm')
        self.plot_green_line = self.plot_widget.add_line(color = 'g')
        self.plot_red_line = self.plot_widget.add_line(color = 'r')
        display_layout.addWidget(self.plot_widget)
        # vertical line
        line = pw.line('V')
        self.layout.addWidget(line)
        # container widget / scroll area
        settings_container_widget = QtGui.QWidget()
        settings_scroll_area = pw.scroll_area()
        settings_scroll_area.setWidget(settings_container_widget)
        settings_scroll_area.setMinimumWidth(300)
        settings_scroll_area.setMaximumWidth(300)
        settings_container_widget.setLayout(QtGui.QVBoxLayout())
        settings_layout = settings_container_widget.layout()
        settings_layout.setMargin(5)
        self.layout.addWidget(settings_scroll_area)
        # opa properties
        input_table = pw.InputTable()
        serial_number_display = pc.Number(initial_value=self.driver.serial_number, decimals=0, display=True)
        input_table.add('Serial Number', serial_number_display)
        settings_layout.addWidget(input_table)
        # display control
        input_table = pw.InputTable()
        input_table.add('Display', None)
        settings_layout.addWidget(input_table)
        # curves
        input_table = pw.InputTable()
        input_table.add('Curves', None)
        settings_layout.addWidget(input_table)
        # motors
        input_table = pw.InputTable()
        input_table.add('Motors', None)
        self.motor_destinations = []
        for motor_name, motor_mutex in self.driver.motor_positions.items():
            input_table.add(motor_name, motor_mutex)
            destination_mutex = motor_mutex.associate(display=False)
            self.motor_destinations.append(destination_mutex)
            input_table.add('Dest. ' + motor_name, destination_mutex)
        settings_layout.addWidget(input_table)
        self.set_motors_button = pw.SetButton('SET')
        settings_layout.addWidget(self.set_motors_button)
        self.set_motors_button.clicked.connect(self.on_set_motors)
        g.module_control.disable_when_true(self.set_motors_button)
        # streach
        settings_layout.addStretch(1)

    def update(self):
        if False:
            # set button disable
            if self.opa.address.busy.read():
                self.set_button.setDisabled(True)
            else:
                self.set_button.setDisabled(False)
            # update destination motor positions
            motor_positions = [mp.read() for mp in self.opa.motor_positions]
            self.grating_destination.write(motor_positions[0])
            self.bbo_destination.write(motor_positions[1])
            self.mixer_destination.write(motor_positions[2])

    def update_plot(self):
        if False:
            points = self.opa.get_points()
            xi = wt_units.converter(points[0], 'wn', self.plot_units.read())
            motor_index = self.opa.motor_names.index(self.plot_motor.read())+1
            yi = points[motor_index]
            self.plot_widget.set_labels(xlabel=self.plot_units.read())
            self.plot_curve.clear()
            self.plot_curve.setData(xi, yi)
            self.plot_widget.graphics_layout.update()

    def update_limits(self):
        if False:
            limits = self.opa.limits.read(self.opa.native_units)
            self.lower_limit.write(limits[0], self.opa.native_units)
            self.upper_limit.write(limits[1], self.opa.native_units)

    def on_set_motors(self):
        inputs = [destination.read() for destination in self.motor_destinations]
        self.driver.address.hardware.q.push('set_motors', inputs)
        self.driver.address.hardware.q.push('get_position')
        
    def show_advanced(self):
        pass

    def stop(self):
        pass



### testing ###################################################################


if __name__ == '__main__':
    
    if True:
        OPA1 = TOPAS(r'C:\Users\John\Desktop\PyCMDS\opas\TOPAS-C\configuration\10743.ini')
        time.sleep(1)
        print OPA1.set_shutter(False)
        print OPA1.get_motor_position(0)
        print OPA1.set_motor_position(0, 3478)
        print OPA1.get_motor_positions_range(0)
        # print OPA1._set_motor_offset
        # print OPA1._set_motor_affix
        # print OPA1._move_motor
        # print OPA1._move_motor_to_position_units
        print OPA1._set_motor_positions_range(0, 0, 9000)
        print OPA1.get_wavelength(0)
        print OPA1._get_motor_affix(0)
        print OPA1._get_device_serial_number()    
        print OPA1._is_wavelength_setting_finished()
        print OPA1._is_motor_still(0)
        print OPA1._get_reference_switch_status(0)
        print OPA1._get_count_of_motors(),
        print OPA1._get_count_of_devices()
        print OPA1._convert_position_to_units(0, 3000)
        print OPA1._convert_position_to_steps(0, -4.)
        print OPA1._get_speed_parameters(0)
        print OPA1._set_speed_parameters(0, 10, 600, 400)
        print OPA1._update_motors_positions()
        print OPA1._stop_motor(0)
        #print OPA1._start_setting_wavelength(1300.)
        #print OPA1._start_setting_wavelength_ex(1300., 0, 0, 0, 0)
        #print OPA1._set_wavelength(1300.)
        print OPA1._start_motor_motion(0, 4000) 
        #print OPA1._set_wavelength_ex(1300., 0, 0, 0, 0)
        #print OPA1.get_interaction(1)
        print OPA1.close()
        
        #log errors and handle them within the OPA object
        #make some convinient methods that are exposed higher up
